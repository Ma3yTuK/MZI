"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseValue = exports.parseAngle = void 0;
exports.parseColor = parseColor;
function parseColor(input) {
    input = input.trim().toLowerCase();
    var parsers = [
        parseHex,
        parseRGB,
        parseHSL,
        parseHSV,
        parseHSI,
        parseHWB,
        parseLAB,
        parseXYZ,
        parseLCH,
        parseYUV,
        parseOklab,
        parseOklch,
        parseHPLuv,
        parseHSLuv,
        parseCIELuv,
        parseCIExyY,
        parseCMYK,
        parseSRGB,
        parseAdobeRGB,
        parseGenericColor
    ];
    for (var _i = 0, parsers_1 = parsers; _i < parsers_1.length; _i++) {
        var parser = parsers_1[_i];
        var result = parser(input);
        if (result)
            return result;
    }
    return null;
}
var parseHex = function (input) {
    var hexRegex = /^#?([0-9a-f]{3,8})$/;
    var match = input.match(hexRegex);
    if (match) {
        var hex = match[1];
        if (hex.length === 3 || hex.length === 4) {
            hex = hex
                .split('')
                .map(function (char) { return char + char; })
                .join('');
        }
        var r = parseInt(hex.substr(0, 2), 16);
        var g = parseInt(hex.substr(2, 2), 16);
        var b = parseInt(hex.substr(4, 2), 16);
        var a = hex.length === 8 ? parseInt(hex.substr(6, 2), 16) / 255 : 1;
        return { r: r, g: g, b: b, a: a };
    }
    return null;
};
var parseRGB = function (input) {
    var rgbRegex = /^rgba?\(?\s*(-?\d+%?)\s*,?\s*(-?\d+%?)\s*,?\s*(-?\d+%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var rgbMatchColon = input.match(/^rgb:?\s*r:(-?\d+%?),?\s*g:(-?\d+%?),?\s*b:(-?\d+%?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(rgbRegex) || rgbMatchColon;
    if (match) {
        var r = match[1], g = match[2], b = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            r: parseValue(r, 255),
            g: parseValue(g, 255),
            b: parseValue(b, 255),
            a: parseValue(a, 1)
        };
    }
    return null;
};
var parseHSL = function (input) {
    var hslRegex = /^hsla?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hslMatchColon = input.match(/^hsl:?\s*h:(-?\d+(?:\.\d+)?),?\s*s:(-?\d+(?:\.\d+)?%?),?\s*l:(-?\d+(?:\.\d+)?%?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hslRegex) || hslMatchColon;
    if (match) {
        var h = match[1], s = match[2], l = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            s: parseValue(s, 100),
            l: parseValue(l, 100),
            a: parseValue(a, 1)
        };
    }
    return null;
};
var parseHSV = function (input) {
    var hsvRegex = /^hsva?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hsvMatchColon = input.match(/^hsv:?\s*h:(-?\d+(?:\.\d+)?),?\s*s:(-?\d+(?:\.\d+)?%?),?\s*v:(-?\d+(?:\.\d+)?%?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hsvRegex) || hsvMatchColon;
    if (match) {
        var h = match[1], s = match[2], v = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            s: parseValue(s, 100),
            v: parseValue(v, 100),
            a: parseValue(a, 1)
        };
    }
    return null;
};
var parseHSI = function (input) {
    var hsiRegex = /^hsia?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hsiMatchColon = input.match(/^hsi:?\s*h:(-?\d+(?:\.\d+)?),?\s*s:(-?\d+(?:\.\d+)?%?),?\s*i:(-?\d+(?:\.\d+)?%?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hsiRegex) || hsiMatchColon;
    if (match) {
        var h = match[1], s = match[2], i = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            s: parseValue(s, 100),
            i: parseValue(i, 100)
        };
    }
    return null;
};
var parseHWB = function (input) {
    var hwbRegex = /^hwba?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hwbMatchColon = input.match(/^hwb:?\s*h:(-?\d+(?:\.\d+)?),?\s*w:(-?\d+(?:\.\d+)?%?),?\s*b:(-?\d+(?:\.\d+)?%?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hwbRegex) || hwbMatchColon;
    if (match) {
        var h = match[1], w = match[2], b = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            w: parseValue(w, 100),
            b: parseValue(b, 100)
        };
    }
    return null;
};
var parseLAB = function (input) {
    var labRegex = /^laba?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var labMatchColon = input.match(/^lab:?\s*l:(-?\d+(?:\.\d+)?%?),?\s*a:(-?\d+(?:\.\d+)?),?\s*b:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(labRegex) || labMatchColon;
    if (match) {
        var l = match[1], a = match[2], b = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            l: parseValue(l, 100),
            a: parseFloat(a),
            b: parseFloat(b)
        };
    }
    return null;
};
var parseXYZ = function (input) {
    var xyzRegex = /^xyza?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var xyzMatchColon = input.match(/^xyz:?\s*x:(-?\d+(?:\.\d+)?%?),?\s*y:(-?\d+(?:\.\d+)?%?),?\s*z:(-?\d+(?:\.\d+)?%?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(xyzRegex) || xyzMatchColon;
    if (match) {
        var x = match[1], y = match[2], z = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            x: parseValue(x, 100),
            y: parseValue(y, 100),
            z: parseValue(z, 100)
        };
    }
    return null;
};
var parseLCH = function (input) {
    var lchRegex = /^lcha?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var lchMatchColon = input.match(/^lch:?\s*l:(-?\d+(?:\.\d+)?%?),?\s*c:(-?\d+(?:\.\d+)?),?\s*h:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(lchRegex) || lchMatchColon;
    if (match) {
        var l = match[1], c = match[2], h = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            l: parseValue(l, 100),
            c: parseFloat(c),
            h: parseAngle(h),
            alpha: parseValue(alpha, 1)
        };
    }
    return null;
};
var parseYUV = function (input) {
    var yuvRegex = /^yuva?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var yuvMatchColon = input.match(/^yuv:?\s*y:(-?\d+(?:\.\d+)?%?),?\s*u:(-?\d+(?:\.\d+)?),?\s*v:(-?\d+(?:\.\d+)?),?\s*a?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(yuvRegex) || yuvMatchColon;
    if (match) {
        var y = match[1], u = match[2], v = match[3], _a = match[4], a = _a === void 0 ? '1' : _a;
        return {
            y: parseValue(y, 100),
            u: parseFloat(u),
            v: parseFloat(v)
        };
    }
    return null;
};
var parseOklab = function (input) {
    var oklabRegex = /^oklaba?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var oklabMatchColon = input.match(/^oklab:?\s*l:(-?\d+(?:\.\d+)?%?),?\s*a:(-?\d+(?:\.\d+)?),?\s*b:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(oklabRegex) || oklabMatchColon;
    if (match) {
        var L = match[1], a = match[2], b = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            L: parseValue(L, 1),
            a: parseFloat(a),
            b: parseFloat(b)
        };
    }
    return null;
};
var parseOklch = function (input) {
    var oklchRegex = /^oklcha?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var oklchMatchColon = input.match(/^oklch:?\s*l:(-?\d+(?:\.\d+)?%?),?\s*c:(-?\d+(?:\.\d+)?),?\s*h:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(oklchRegex) || oklchMatchColon;
    if (match) {
        var L = match[1], C = match[2], h = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            L: parseValue(L, 1),
            C: parseFloat(C),
            h: parseAngle(h)
        };
    }
    return null;
};
var parseHPLuv = function (input) {
    var hpluvRegex = /^hpluva?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hpluvMatchColon = input.match(/^hpluv:?\s*h:(-?\d+(?:\.\d+)?),?\s*p:(-?\d+(?:\.\d+)?%?),?\s*l:(-?\d+(?:\.\d+)?%?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hpluvRegex) || hpluvMatchColon;
    if (match) {
        var h = match[1], p = match[2], l = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            p: parseValue(p, 100),
            l: parseValue(l, 100)
        };
    }
    return null;
};
var parseHSLuv = function (input) {
    var hsluvRegex = /^hsluva?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var hsluvMatchColon = input.match(/^hsluv:?\s*h:(-?\d+(?:\.\d+)?),?\s*s:(-?\d+(?:\.\d+)?%?),?\s*l:(-?\d+(?:\.\d+)?%?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(hsluvRegex) || hsluvMatchColon;
    if (match) {
        var h = match[1], s = match[2], l = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            h: parseAngle(h),
            s: parseValue(s, 100),
            l: parseValue(l, 100)
        };
    }
    return null;
};
var parseCIELuv = function (input) {
    var cieluvRegex = /^cieluva?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var cieluvMatchColon = input.match(/^cieluv:?\s*l:(-?\d+(?:\.\d+)?%?),?\s*u:(-?\d+(?:\.\d+)?),?\s*v:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(cieluvRegex) || cieluvMatchColon;
    if (match) {
        var L = match[1], u = match[2], v = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            L: parseValue(L, 100),
            u: parseFloat(u),
            v: parseFloat(v)
        };
    }
    return null;
};
var parseCIExyY = function (input) {
    var ciexyYRegex = /^ciexyya?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var ciexyYMatchColon = input.match(/^ciexyy:?\s*x:(-?\d+(?:\.\d+)?),?\s*y:(-?\d+(?:\.\d+)?),?\s*Y:(-?\d+(?:\.\d+)?%?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(ciexyYRegex) || ciexyYMatchColon;
    if (match) {
        var x = match[1], y = match[2], Y = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            x: parseFloat(x),
            y: parseFloat(y),
            Y: parseValue(Y, 100)
        };
    }
    return null;
};
var parseCMYK = function (input) {
    var cmykRegex = /^cmyka?\(?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?\d+(?:\.\d+)?%?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var cmykMatchColon = input.match(/^cmyk:?\s*c:(-?\d+(?:\.\d+)?%?),?\s*m:(-?\d+(?:\.\d+)?%?),?\s*y:(-?\d+(?:\.\d+)?%?),?\s*k:(-?\d+(?:\.\d+)?%?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(cmykRegex) || cmykMatchColon;
    if (match) {
        var c = match[1], m = match[2], y = match[3], k = match[4], _a = match[5], alpha = _a === void 0 ? '1' : _a;
        return {
            c: parseValue(c, 100),
            m: parseValue(m, 100),
            y: parseValue(y, 100),
            k: parseValue(k, 100)
        };
    }
    return null;
};
var parseSRGB = function (input) {
    var srgbRegex = /^srgba?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var srgbMatchColon = input.match(/^srgb:?\s*sr:(-?\d+(?:\.\d+)?),?\s*sg:(-?\d+(?:\.\d+)?),?\s*sb:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(srgbRegex) || srgbMatchColon;
    if (match) {
        var sr = match[1], sg = match[2], sb = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            sr: parseFloat(sr),
            sg: parseFloat(sg),
            sb: parseFloat(sb)
        };
    }
    return null;
};
var parseAdobeRGB = function (input) {
    var adobeRGBRegex = /^adobergba?\(?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)\s*,?\s*(-?[\d.]+%?)?\s*\)?$/i;
    var adobeRGBMatchColon = input.match(/^adobergb:?\s*ar:(-?\d+(?:\.\d+)?),?\s*ag:(-?\d+(?:\.\d+)?),?\s*ab:(-?\d+(?:\.\d+)?),?\s*alpha?:?(-?[\d.]+%?)?\s*$/i);
    var match = input.match(adobeRGBRegex) || adobeRGBMatchColon;
    if (match) {
        var ar = match[1], ag = match[2], ab = match[3], _a = match[4], alpha = _a === void 0 ? '1' : _a;
        return {
            ar: parseFloat(ar),
            ag: parseFloat(ag),
            ab: parseFloat(ab)
        };
    }
    return null;
};
var parseGenericColor = function (input) {
    var genericRegex = /^color\(\s*--(\w+)\s+([-\d.%\s]+)\s*\)$/i;
    var match = input.match(genericRegex);
    if (match) {
        var colorSpace = match[1], values = match[2];
        var parsedValues = values
            .trim()
            .split(/\s+/)
            .map(function (v) { return parseValue(v, 100); });
        switch (colorSpace.toLowerCase()) {
            case 'rgb':
                return { r: parsedValues[0], g: parsedValues[1], b: parsedValues[2], a: parsedValues[3] || 1 };
            case 'hsl':
                return { h: parsedValues[0], s: parsedValues[1], l: parsedValues[2], a: parsedValues[3] || 1 };
            case 'hsv':
                return { h: parsedValues[0], s: parsedValues[1], v: parsedValues[2], a: parsedValues[3] || 1 };
            case 'hwb':
                return { h: parsedValues[0], w: parsedValues[1], b: parsedValues[2], a: parsedValues[3] || 1 };
            case 'lab':
                return { l: parsedValues[0], a: parsedValues[1], b: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'lch':
                return { l: parsedValues[0], c: parsedValues[1], h: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'oklab':
                return { L: parsedValues[0], a: parsedValues[1], b: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'oklch':
                return { L: parsedValues[0], C: parsedValues[1], h: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'xyz':
                return { x: parsedValues[0], y: parsedValues[1], z: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'yuv':
                return { y: parsedValues[0], u: parsedValues[1], v: parsedValues[2], a: parsedValues[3] || 1 };
            case 'hsi':
                return { h: parsedValues[0], s: parsedValues[1], i: parsedValues[2], a: parsedValues[3] || 1 };
            case 'hsluv':
                return { h: parsedValues[0], s: parsedValues[1], l: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'hpluv':
                return { h: parsedValues[0], p: parsedValues[1], l: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'cieluv':
                return { L: parsedValues[0], u: parsedValues[1], v: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'ciexyy':
                return { x: parsedValues[0], y: parsedValues[1], Y: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'cmyk':
                return {
                    c: parsedValues[0],
                    m: parsedValues[1],
                    y: parsedValues[2],
                    k: parsedValues[3],
                    alpha: parsedValues[4] || 1
                };
            case 'srgb':
                return { sr: parsedValues[0], sg: parsedValues[1], sb: parsedValues[2], alpha: parsedValues[3] || 1 };
            case 'adobergb':
                return { ar: parsedValues[0], ag: parsedValues[1], ab: parsedValues[2], alpha: parsedValues[3] || 1 };
            default:
                return null;
        }
    }
    return null;
};
var parseValue = function (value, max) {
    if (value.endsWith('%')) {
        return (parseFloat(value) / 100) * max;
    }
    return parseFloat(value);
};
exports.parseValue = parseValue;
var parseAngle = function (angle) {
    var value = parseFloat(angle);
    if (angle.endsWith('deg')) {
        return value % 360;
    }
    else if (angle.endsWith('grad')) {
        return (value * 0.9) % 360;
    }
    else if (angle.endsWith('rad')) {
        return ((value * 180) / Math.PI) % 360;
    }
    else if (angle.endsWith('turn')) {
        return (value * 360) % 360;
    }
    return value % 360;
};
exports.parseAngle = parseAngle;
