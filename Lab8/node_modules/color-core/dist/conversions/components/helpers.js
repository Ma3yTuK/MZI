"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lToY = lToY;
exports.yToL = yToL;
exports.distanceFromOrigin = distanceFromOrigin;
exports.distanceFromOriginAngle = distanceFromOriginAngle;
exports.calcMaxChromaHsluv = calcMaxChromaHsluv;
exports.calcMaxChromaHpluv = calcMaxChromaHpluv;
exports.calculateBoundingLines = calculateBoundingLines;
exports.luvToLch = luvToLch;
exports.xyzToLuv = xyzToLuv;
exports.lchToLuv = lchToLuv;
exports.luvToXyz = luvToXyz;
var constants_1 = require("./constants");
/**
 * Calculates the Y value in the CIELAB color space based on the given L value.
 *
 * @param {number} l - The L value representing the lightness.
 * @return {number} The calculated Y value.
 */
function lToY(l) {
    if (l <= 8) {
        return constants_1.constants.refY * l / constants_1.constants.kappa;
    }
    return constants_1.constants.refY * Math.pow((l + 16) / 116, 3);
}
/**
 * Calculates the lightness value (L) in the CIELAB color space based on the given Y value.
 *
 * @param {number} y - The Y value representing the lightness.
 * @return {number} The calculated lightness value (L).
 */
function yToL(y) {
    if (y <= constants_1.constants.epsilonlow) {
        return y * constants_1.constants.kappa / constants_1.constants.refY;
    }
    return 116 * Math.pow(y / constants_1.constants.refY, 1 / 3) - 16;
}
/**
 * Calculates the distance from the origin on a line defined by a slope and intercept.
 *
 * @param {number} slope - The slope of the line.
 * @param {number} intercept - The intercept of the line.
 * @return {number} The distance from the origin.
 */
function distanceFromOrigin(slope, intercept) {
    return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
}
/**
 * Calculates the distance from the origin on a line defined by a slope and intercept.
 *
 * @param {number} slope - The slope of the line.
 * @param {number} intercept - The intercept of the line.
 * @param {number} angle - The angle of the line in radians.
 * @return {number} The distance from the origin. If the distance is negative, returns Infinity.
 */
function distanceFromOriginAngle(slope, intercept, angle) {
    var denominator = Math.sin(angle) - slope * Math.cos(angle);
    if (denominator === 0) {
        return Infinity;
    }
    var d = intercept / denominator;
    return d < 0 ? Infinity : d;
}
/**
 * Calculates the maximum chroma value in the HSLuv color space.
 *
 * @param {number} l - The lightness value.
 * @param {number} h - The hue value.
 * @return {number} The maximum chroma value.
 */
function calcMaxChromaHsluv(l, h) {
    var hueRad = h / 360 * Math.PI * 2;
    var lines = calculateBoundingLines(l);
    var distances = lines.map(function (line) { return distanceFromOriginAngle(line[0], line[1], hueRad); });
    return Math.min.apply(Math, distances);
}
/**
 * Calculates the maximum chroma value for a given set of lines in the HPLuv color space.
 *
 * @param {number[][]} lines - An array of lines, each represented by an array of two numbers.
 * @return {number} The maximum chroma value.
 */
function calcMaxChromaHpluv(lines) {
    var r0 = distanceFromOrigin(lines[0][0], lines[0][1]);
    var r1 = distanceFromOrigin(lines[1][0], lines[1][1]);
    var g0 = distanceFromOrigin(lines[2][0], lines[2][1]);
    var g1 = distanceFromOrigin(lines[3][0], lines[3][1]);
    var b0 = distanceFromOrigin(lines[4][0], lines[4][1]);
    var b1 = distanceFromOrigin(lines[5][0], lines[5][1]);
    return Math.min(r0, r1, g0, g1, b0, b1);
}
/**
 * Calculates the bounding lines for a given lightness value.
 *
 * @param {number} l - The lightness value.
 * @return {number[][]} An array of lines, each represented by an array of two numbers.
 */
function calculateBoundingLines(l) {
    var sub1 = Math.pow(l + 16, 3) / 1560896;
    var sub2 = sub1 > constants_1.constants.epsilonlow ? sub1 : l / constants_1.constants.kappa;
    var lines = [];
    for (var i = 0; i < 3; i++) {
        var m1 = constants_1.constants.m[i][0];
        var m2 = constants_1.constants.m[i][1];
        var m3 = constants_1.constants.m[i][2];
        var s1 = sub2 * (284517 * m1 - 94839 * m3);
        var s2 = sub2 * (838422 * m3 + 769860 * m2 + 731718 * m1);
        var s3 = sub2 * (632260 * m3 - 126452 * m2);
        var s0 = s1 / s3;
        var s1_1 = s1 / (s3 + 126452);
        lines.push([s0, s2 * l / s3]);
        lines.push([s1_1, (s2 - 769860) * l / (s3 + 126452)]);
    }
    return lines;
}
/**
 * Converts a color from the LUV color space to the LCH color space.
 *
 * @param {LUV} luv - The LUV color to convert.
 * @return {LCH} The converted LCH color.
 */
function luvToLch(luv) {
    var c = Math.sqrt(luv.u * luv.u + luv.v * luv.v);
    var h;
    if (c < 0.00000001) {
        h = 0;
    }
    else {
        h = Math.atan2(luv.v, luv.u) * 180.0 / Math.PI;
        if (h < 0) {
            h = 360 + h;
        }
    }
    return { l: luv.L, c: c, h: h };
}
/**
 * Converts XYZ to LUV.
 * @param xyz - The XYZ color to convert.
 * @returns The converted LUV color.
 */
function xyzToLuv(xyz) {
    var divider = xyz.x + 15 * xyz.y + 3 * xyz.z;
    var varU = 4 * xyz.x;
    var varV = 9 * xyz.y;
    if (divider !== 0) {
        varU /= divider;
        varV /= divider;
    }
    else {
        varU = NaN;
        varV = NaN;
    }
    var l = yToL(xyz.y);
    if (l === 0) {
        return { L: 0, u: 0, v: 0 };
    }
    var u = 13 * l * (varU - constants_1.constants.refU);
    var v = 13 * l * (varV - constants_1.constants.refV);
    return { L: l, u: u, v: v };
}
/**
 * Converts LCH to LUV.
 * @param lch - The LCH color to convert.
 * @returns The converted LUV color.
 */
function lchToLuv(lch) {
    var hrad = lch.h / 180.0 * Math.PI;
    return {
        L: lch.l,
        u: Math.cos(hrad) * lch.c,
        v: Math.sin(hrad) * lch.c
    };
}
/**
 * Converts LUV to XYZ.
 * @param luv - The LUV color to convert.
 * @returns The converted XYZ color.
 */
function luvToXyz(luv) {
    if (luv.L === 0) {
        return { x: 0, y: 0, z: 0 };
    }
    var varU = luv.u / (13 * luv.L) + constants_1.constants.refU;
    var varV = luv.v / (13 * luv.L) + constants_1.constants.refV;
    var y = lToY(luv.L);
    var x = 0 - 9 * y * varU / ((varU - 4) * varV - varU * varV);
    var z = (9 * y - 15 * varV * y - varV * x) / (3 * varV);
    return { x: x, y: y, z: z };
}
