"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Color = void 0;
var accessability_1 = require("./accessability");
var relative_luminance_1 = require("./accessability/components/relative-luminance");
var conversions_1 = require("./conversions");
var harmony_1 = require("./harmony");
var manipulation_1 = require("./manipulation");
var utils_1 = require("./utils");
var color_naming_1 = require("./utils/components/color-naming");
/**
 * The Color class represents a color with various color space representations and manipulation methods.
 *
 * The class supports multiple color spaces, including RGB, HSL, HSV, CMYK, LAB, LCH, XYZ, and YUV.
 * It also provides methods for converting between color spaces and generating harmony colors.
 *
 * The class offers various color manipulation methods, such as adjusting lightness, saturation, hue, and alpha.
 * It also provides methods for converting colors to different string representations and retrieving information about the color.
 *
 * The class also includes utility methods for determining the perceived brightness of the color and checking if it is light or dark.
 */
var Color = /** @class */ (function () {
    function Color(color) {
        if (typeof color === 'string') {
            var parsedColor = (0, utils_1.parseColor)(color);
            if (parsedColor) {
                this._rgb = this.convertToRgb(parsedColor);
            }
            else {
                throw new Error('Invalid color format');
            }
        }
        else {
            this._rgb = this.convertToRgb(color);
        }
        if (this._rgb.a === undefined) {
            this._rgb.a = undefined;
        }
        this._rgb = this.roundObject(this._rgb);
    }
    Color.prototype.convertToRgb = function (color) {
        var _a;
        if ('r' in color && 'g' in color && 'b' in color)
            return __assign(__assign({}, color), { a: (_a = color.a) !== null && _a !== void 0 ? _a : 1 });
        if ('sr' in color && 'sg' in color && 'sb' in color)
            return (0, conversions_1.srgbToRgb)(color);
        if ('x' in color && 'y' in color && 'z' in color)
            return (0, conversions_1.xyzToRgb)(color);
        if ('l' in color && 'a' in color && 'b' in color)
            return (0, conversions_1.labToRgb)(color);
        if ('l' in color && 'c' in color && 'h' in color)
            return (0, conversions_1.lchToRgb)(color);
        if ('y' in color && 'u' in color && 'v' in color)
            return (0, conversions_1.yuvToRgb)(color);
        if ('L' in color && 'u' in color && 'v' in color)
            return (0, conversions_1.cieLuvToRgb)(color);
        if ('L' in color && 'a' in color && 'b' in color)
            return (0, conversions_1.oklabToRgb)(color);
        if ('L' in color && 'C' in color && 'h' in color)
            return (0, conversions_1.oklchToRgb)(color);
        if ('x' in color && 'y' in color && 'Y' in color)
            return (0, conversions_1.ciexyyToRgb)(color);
        if ('h' in color && 's' in color && 'i' in color)
            return (0, conversions_1.hsiToRgb)(color);
        if ('h' in color && 'w' in color && 'b' in color)
            return (0, conversions_1.hwbToRgb)(color);
        if ('h' in color && 's' in color && 'l' in color)
            return (0, conversions_1.hslToRgb)(color);
        if ('h' in color && 's' in color && 'v' in color)
            return (0, conversions_1.hsvToRgb)(color);
        if ('h' in color && 'p' in color && 'l' in color)
            return (0, conversions_1.hpluvToRgb)(color);
        if ('c' in color && 'm' in color && 'y' in color && 'k' in color)
            return (0, conversions_1.cmykToRgb)(color);
        if ('ar' in color && 'ag' in color && 'ab' in color)
            return (0, conversions_1.adobeRGBToRGB)(color);
        throw new Error('Invalid color format');
    };
    Object.defineProperty(Color.prototype, "r", {
        // Getters and setters
        get: function () {
            return this._rgb.r;
        },
        set: function (value) {
            this._rgb.r = Math.max(0, Math.min(255, Math.round(value)));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        get: function () {
            return this._rgb.g;
        },
        set: function (value) {
            this._rgb.g = Math.max(0, Math.min(255, Math.round(value)));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        get: function () {
            return this._rgb.b;
        },
        set: function (value) {
            this._rgb.b = Math.max(0, Math.min(255, Math.round(value)));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "a", {
        get: function () {
            return this._rgb.a;
        },
        set: function (value) {
            if (value === undefined) {
                this._rgb.a = undefined;
            }
            else {
                this._rgb.a = Math.max(0, Math.min(1, value));
            }
        },
        enumerable: false,
        configurable: true
    });
    // Conversion methods
    Color.prototype.toRgb = function () {
        var _a = this._rgb, r = _a.r, g = _a.g, b = _a.b, a = _a.a;
        return a === undefined ? { r: r, g: g, b: b } : { r: r, g: g, b: b, a: a };
    };
    Color.prototype.toHex = function (includeAlpha) {
        if (includeAlpha === void 0) { includeAlpha = this._rgb.a !== 1; }
        return (0, conversions_1.rgbToHex)(this._rgb, includeAlpha);
    };
    Color.prototype.toSrgb = function () {
        return this.roundObject((0, conversions_1.rgbToSrgb)(this._rgb));
    };
    Color.prototype.toHsl = function () {
        return this.roundObject((0, conversions_1.rgbToHsl)(this._rgb));
    };
    Color.prototype.toHsv = function () {
        return this.roundObject((0, conversions_1.rgbToHsv)(this._rgb));
    };
    Color.prototype.toHsi = function () {
        return this.roundObject((0, conversions_1.rgbToHsi)(this._rgb));
    };
    Color.prototype.toHwb = function () {
        return this.roundObject((0, conversions_1.rgbToHwb)(this._rgb));
    };
    Color.prototype.toLch = function () {
        return this.roundObject((0, conversions_1.rgbToLch)(this._rgb));
    };
    Color.prototype.toYuv = function () {
        return this.roundObject((0, conversions_1.rgbToYuv)(this._rgb));
    };
    Color.prototype.toCmyk = function () {
        return this.roundObject((0, conversions_1.rgbToCmyk)(this._rgb));
    };
    Color.prototype.toOklab = function () {
        return this.roundObject((0, conversions_1.rgbToOklab)(this._rgb));
    };
    Color.prototype.toOklch = function () {
        return this.roundObject((0, conversions_1.rgbToOklch)(this._rgb));
    };
    Color.prototype.toHSLuv = function () {
        return this.roundObject((0, conversions_1.rgbToHSLuv)(this._rgb));
    };
    Color.prototype.toHPLuv = function () {
        return this.roundObject((0, conversions_1.rgbToHPLuv)(this._rgb));
    };
    Color.prototype.toCIELuv = function () {
        return this.roundObject((0, conversions_1.rgbToCIELuv)(this._rgb));
    };
    Color.prototype.toCIExyY = function () {
        return this.roundObject((0, conversions_1.rgbToCIExyY)(this._rgb));
    };
    Color.prototype.toAdobeRGB = function () {
        return this.roundObject((0, conversions_1.rgbToAdobeRGB)(this._rgb));
    };
    Color.prototype.toXyz = function () {
        return this.roundObject((0, conversions_1.rgbToXyz)(this._rgb));
    };
    Color.prototype.toXyzD50 = function () {
        return this.roundObject((0, conversions_1.rgbToXyzD50)(this._rgb));
    };
    Color.prototype.toLab = function () {
        return this.roundObject((0, conversions_1.rgbToLab)(this._rgb));
    };
    Color.prototype.toLabD50 = function () {
        return this.roundObject((0, conversions_1.rgbToLabD50)(this._rgb));
    };
    // Harmony methods
    Color.prototype.complementary = function () {
        return (0, harmony_1.complementary)(this);
    };
    Color.prototype.analogous = function (angle) {
        return (0, harmony_1.analogous)(this, angle);
    };
    Color.prototype.triadic = function () {
        return (0, harmony_1.triadic)(this);
    };
    Color.prototype.tetradic = function (angle) {
        return (0, harmony_1.tetradic)(this);
    };
    Color.prototype.splitComplementary = function (angle) {
        return (0, harmony_1.splitComplementary)(this, angle);
    };
    Color.prototype.monochromatic = function (count) {
        return (0, harmony_1.monochromatic)(this, count);
    };
    Color.prototype.square = function () {
        return (0, harmony_1.square)(this);
    };
    Color.prototype.doubleSplitComplementary = function (angle) {
        return (0, harmony_1.doubleSplitComplementary)(this);
    };
    Color.prototype.shades = function (count) {
        return (0, harmony_1.shades)(this, count);
    };
    Color.prototype.tints = function (count) {
        return (0, harmony_1.tints)(this, count);
    };
    Color.prototype.tones = function (count) {
        return (0, harmony_1.tones)(this, count);
    };
    // Manipulation methods
    Color.prototype.adjustLightness = function (amount) {
        return (0, manipulation_1.adjustLightness)(this, amount);
    };
    Color.prototype.adjustSaturation = function (amount) {
        return (0, manipulation_1.adjustSaturation)(this, amount);
    };
    Color.prototype.adjustHue = function (amount) {
        return (0, manipulation_1.adjustHue)(this, amount);
    };
    Color.prototype.adjustAlpha = function (amount) {
        return (0, manipulation_1.adjustAlpha)(this, amount);
    };
    Color.prototype.invert = function () {
        return (0, manipulation_1.invert)(this);
    };
    Color.prototype.grayscale = function () {
        return (0, manipulation_1.grayscale)(this);
    };
    Color.prototype.mix = function (color, amount) {
        return (0, manipulation_1.mix)(this, color, amount);
    };
    // Utility methods
    Color.setPrecision = function (precision) {
        Color.PRECISION = precision;
    };
    Color.prototype.toString = function (includeAlpha) {
        if (includeAlpha === void 0) { includeAlpha = false; }
        return this.toHex(includeAlpha);
    };
    Color.prototype.setAlpha = function (value) {
        this.a = value;
        return this;
    };
    Color.prototype.getEffectiveAlpha = function () {
        var _a;
        return (_a = this.a) !== null && _a !== void 0 ? _a : 1;
    };
    Color.prototype.getName = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, color_naming_1.getColorName)(this)];
            });
        });
    };
    Color.prototype.getInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, color_naming_1.getColorInfo)(this)];
            });
        });
    };
    Color.prototype.getBrightness = function () {
        return (0, utils_1.calculateBrightness)(this._rgb);
    };
    Color.prototype.isLight = function (threshold) {
        if (threshold === void 0) { threshold = 128; }
        return (0, utils_1.isLightColor)(this._rgb, threshold);
    };
    /**
     * Calculates the relative luminance of the color.
     * @returns The relative luminance value between 0 and 1.
     */
    Color.prototype.getRelativeLuminance = function () {
        return (0, relative_luminance_1.getRelativeLuminance)(this);
    };
    /**
     * Calculates the contrast ratio between this color and another color.
     * @param otherColor The color to compare against.
     * @returns The contrast ratio between the two colors.
     */
    Color.prototype.getContrastRatio = function (otherColor) {
        return (0, accessability_1.getContrastRatio)(this, otherColor);
    };
    /**
     * Determines the WCAG compliance level for the contrast between this color and another color.
     * @param otherColor The color to compare against.
     * @param size The size of the text ('Normal' or 'Large').
     * @returns An object containing the compliance level and the contrast ratio.
     */
    Color.prototype.getWCAGCompliance = function (otherColor, size) {
        return (0, accessability_1.getWCAGCompliance)(this, otherColor, size);
    };
    Color.prototype.equals = function (other) {
        var rgb1 = this.toRgb();
        var rgb2 = other.toRgb();
        return rgb1.r === rgb2.r && rgb1.g === rgb2.g && rgb1.b === rgb2.b && rgb1.a === rgb2.a;
    };
    Color.prototype.roundNumber = function (num) {
        return Number(num.toFixed(Color.PRECISION));
    };
    Color.prototype.roundObject = function (obj) {
        var _this = this;
        return Object.fromEntries(Object.entries(obj).map(function (_a) {
            var key = _a[0], value = _a[1];
            return [key, typeof value === 'number' ? _this.roundNumber(value) : value];
        }));
    };
    Color.PRECISION = 6;
    return Color;
}());
exports.Color = Color;
